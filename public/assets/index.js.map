{"version":3,"sources":["index.js"],"names":["i","s","o","g","r","a","m","q","push","arguments","l","Date","createElement","getElementsByTagName","async","src","parentNode","insertBefore","window","document","ga","w","d","userSwitch","id","positions","callback","index","getElementById","addEventListener","length","container","canvas","context","getContext","particles","defaults","shape","phase","renderers","circle","state","arc","x","y","radius","triangle","len","moveTo","lineTo","bar","width","alpha","height","value","parseInt","Math","random","Object","keys","clientWidth","dispatchEvent","Event","color","sin","update","floor","velocity","draw","beginPath","fillStyle","fill","animate","clearRect","requestAnimationFrame","maxBubbles","addBubbles","setInterval","clearInterval"],"mappings":"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","file":"index.js","sourcesContent":["(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','//www.google-analytics.com/analytics.js','ga');\nga('create', 'UA-25609352-3', 'auto');\nga('send', 'pageview');\n\n((w, d) => {\n    function userSwitch(id, positions, callback) {\n        let index = 0;\n\n        d.getElementById(id).addEventListener('click', function(){\n            index = index >= positions.length - 1 ? 0 : index + 1;\n            callback(positions[index]);\n        });\n    }\n\n    const container = d.getElementsByTagName('footer')[0];\n    const canvas = d.getElementsByTagName('canvas')[0];\n    const context = canvas.getContext('2d');\n    const particles = [];\n\n    const defaults = {\n        shape: 'circle',\n        phase: () => {},\n    };\n\n    const renderers = {\n        'circle': (state) => {\n            // the -radius to spawn above the fold\n            context.arc(state.x, state.y - state.radius, state.radius, 0, 6.2832);\n        },\n        'triangle': (state) => {\n            const len = state.radius * 3;\n\n            context.moveTo(state.x, state.y); // left\n            context.lineTo(state.x + (len / 2), state.y - (len * 0.9)); // top\n            context.lineTo(state.x + len, state.y); // right\n        },\n        'bar': (state) => {\n            // width is tied to alpha so it shrinks as time goes on\n            const width = (state.radius * 2) + (state.alpha * 10);\n            const height = 120;\n\n            context.moveTo(state.x, state.y); // bottom left\n            context.lineTo(state.x + width, state.y); // bottom right\n            context.lineTo(state.x + width, state.y - height); // top right\n            context.lineTo(state.x, state.y - height); // top left\n        },\n    };\n\n    userSwitch('color', [0, 1, 2], value => {\n        if (value === 0) {\n            defaults.phase = () => null;\n        }\n        else if (value == 1) {\n            defaults.phase = () => parseInt(Math.random() * 20);\n        }\n        else if (value == 2) {\n            defaults.phase = (x) => x / 180;\n        }\n    });\n\n    userSwitch('shape', Object.keys(renderers), value => {\n        defaults.shape = value;\n    });\n\n    // keep the canvas at the right size as the window changes\n    w.addEventListener('resize', () => {\n        canvas.width = container.clientWidth;\n    });\n    w.dispatchEvent(new Event('resize'));\n\n    function color(state) {\n        if (state.phase) {\n            return parseInt(Math.sin(0.0314 * state.y + 2 + state.phase) * 127 + 128) +','+\n                   parseInt(Math.sin(0.0314 * state.y + 0 + state.phase) * 127 + 128) +','+\n                   parseInt(Math.sin(0.0314 * state.y + 4 + state.phase) * 127 + 128);\n        }\n\n        return state.color;\n    }\n\n    function update(state) {\n        if (!state || state.alpha < 0) {\n            const radius = 0.05 + Math.random() * 5.3;\n            const x = Math.floor(Math.random() * (canvas.width - (radius*2) - 3)) + radius;\n\n            return {\n                x: x,\n                y: 0,\n                alpha: 0.6 + Math.random() * 0.3,\n                radius: radius,\n                velocity: Math.floor(Math.random() * 1.5) + 1,\n                color: '100,100,100',\n                phase: defaults.phase(x),\n                shape: defaults.shape,\n            };\n        }\n\n        return {\n            x: state.x,\n            y: state.y + state.velocity,\n            alpha: state.alpha - 0.025,\n            radius: state.radius,\n            velocity: state.velocity + 0.1,\n            color: color(state),\n            phase: state.phase,\n            shape: state.shape,\n        };\n    }\n\n    function draw(state) {\n        context.beginPath();\n\n        renderers[state.shape](state);\n\n        context.fillStyle = 'rgba('+ state.color +','+ state.alpha +')';\n        context.fill();\n    }\n\n    function animate() {\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        for (let i = particles.length; i--;) {\n            draw(particles[i] = update(particles[i]));\n        }\n\n        requestAnimationFrame(animate);\n    }\n\n    // if we add all the particles at once then they come in waves\n    const maxBubbles = canvas.width / 5;\n    const addBubbles = setInterval(() => {\n        if (particles.length > maxBubbles) {\n            return clearInterval(addBubbles);\n        }\n\n        for (let x = 0; x < 10; x++) {\n            particles.push(update());\n        }\n    }, 100);\n\n    animate();\n})(window, document);\n"],"sourceRoot":"/source/"}